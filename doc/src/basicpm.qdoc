/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the documentation of ProcessManager
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\page basicpm.html
\previouspage Understanding ProcessInfo
\contentspage {Backend Process Manager} {Contents}
\nextpage Standard Process Manager

\title Backend Process Manager

The basic C++ API for controlling processes uses the ProcessBackendManager.
The ProcessBackendManager contains an ordered list of ProcessBackendFactory objects,
which are used to convert ProcessInfo objects into executable processes.

The ProcessBackendManager can be used as follows:

\code
  ProcessBackendManager *manager = new ProcessBackendManager;
  manager->add(new UnixProcessBackendFactory);

  ProcessInfo info;
  info.setName("lstest");
  info.setProgram("/bin/ls");
  info.setWorkingDirectory("/root");

  ProcessBackend *backend = manager->create(info);
  if (backend) {
    connect(backend, SIGNAL(started()), this, SLOT(processStarted()));
    connect(backend, SIGNAL(finished(int, QProcess::ExitStatus)),
            this, SLOT(processFinished(int, QProcess::ExitStatus)));
    backend->start();
  }
\endcode

The first step of initializing the ProcessBackendManager is to assign
ProcessBackendFactory objects.  The order of the factories is important.
The ProcessBackendManager::create() function asks each factory in turn
if it can handle the ProcessInfo object.  The first factory to match
is the one that creates the ProcessBackend object.
The backend object behaves similarly to a QProcess object; one normally
attaches a few signal handlers and then starts the backend running.
Please note the it is the user's responsibility to correctly delete
the backend object.

In the next example, we'd like to be able to launch certain processes
under GDB.  To do this, we add a new StandardProcessBackendFactory and
set a custom MatchDelegate and RewriteDelegate.  A KeyMatchDelegate will
match ProcessInfo records that contain a particular key value.  We
set the delegate to match records containing a "gdb" key.  We also
add a GdbRewritedDelegate which rewrites the ProcessInfo record to
execute the process under gdb.

Note that the order of the factories is important; the normal
StandardProcessBackendFactory will match anything, so it must go last.

\code
  ProcessBackendManager *manager = new ProcessBackendManager;

  StandardProcessBackendFactory *gdb_factory = new StandardProcessBackendFactory;

  KeyMatchDelegate *keymatch = new KeyMatchDelegate;
  keymatch->setKey("gdb");
  gdb_factory->setMatchDelegate(keymatch);
  gdb_factory->setRewriteDelegate(new GdbRewriteDelegate);

  manager->add(gdb_factory);
  manager->add(new StandardProcessBackendFactory);

  ProcessInfo info;
  info.setName("lstest");
  info.setProgram("/bin/ls");
  info.setWorkingDirectory("/root");
  info.setValue("gdb", "true");

  ProcessBackend *backend = manager->create(info);
  if (backend) {
    connect(backend, SIGNAL(started()), this, SLOT(processStarted()));
    connect(backend, SIGNAL(finished(int, QProcess::ExitStatus)),
            this, SLOT(processFinished(int, QProcess::ExitStatus)));
    backend->start();
  }
\endcode

\section1 Inheritence Hierarchy

\image processbackend_hierarchy.png {Process Backend Hierarchy}
\caption \i{Process Backend Hierarchy}

The virtual ProcessBackend object hierarchy is divided into two
sections: the UnixProcessBackend objects contain a QProcess internally
and the RemoteProcessBackend objects communicate with a separate process
"launcher" program.  It may sound odd that a process manager would not
launch its own processes, but this mechanism allows the process
manager to not run with setuid privileges.

\image processbackendfactory_hierarchy.png
\caption \i{Process Backend Factory Hierarchy}

The ProcessBackendFactory hierarchy closely matches the ProcessBackend
hierarchy.  The standard and prelaunch subclasses create standard and
prelaunch process backend objects.  The remote subclass is divided
by how it connects to the remote "launcher" program; either over a
pipe connection or a socket connection.

*/
