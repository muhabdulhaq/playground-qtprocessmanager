/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the documentation of ProcessManager
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\page standardpm.html
\previouspage Backend Process Manager
\contentspage {Standard Process Manager} {Contents}
\nextpage Declarative Process Manager

\title Standard Process Manager

The standard ProcessManager object wraps the ProcessBackendManager
object, creates ProcessFrontend objects to wrap each ProcessBackend
object, and assigns unique string identifiers to each process.
This approach provides several advantages.  First, the ProcessManager can
maintain a list of running processes indexed by identifier.  Second, the
ProcessFrontend objects can be subclassed.  This provides a convenient
way of adding convenience functions to the ProcessFrontend objects. Third,
instead of connecting to signals from each process, one can subclass
the ProcessManager itself and override the handler functions.

The unique identifier assigned to each process created takes the form
of "NAME-NUMBER", where NAME comes from the ProcessInfo.name attribute
and NUMBER is a unique integer assigned at process creation.

\section2 Directly using the ProcessManager

You can directly use the ProcessManager in your code.
\code
void MyClass::setup()
{
  ProcessManager *manager = new ProcessManager;
  manager->addFactory(new UnixProcessBackendFactory);
  m_manager = manager;
}

void MyClass::start(ProcessInfo info)
{
  ProcessFrontend *frontend = m_manager->start(info);
  connect(frontend, SIGNAL(started()), SLOT(started()));
  connect(frontend, SIGNAL(finished(int, QProcess::ExitStatus)),
                   SLOT(finished(int, QProcess::ExitStatus)));
}

void MyClass::started()
{
  ProcessFrontend *frontend = qobject_cast<ProcessFrontend *>(sender());
  if (frontend)
    qDebug() << "Process" << identifier << "started with pid=" << frontend->pid();
}

void MyClass::finished(int exitCode, QProcess::ExitStatus exitStatus)
{
  ProcessFrontend *frontend = qobject_cast<ProcessFrontend *>(sender());
  if (frontend)
    qDebug() << "Process" << identifier << "stopped with" << exitCode << exitStatus;
}
\endcode


\section2 Subclassing ProcessManager

You can subclass the process manager to gain more control.  This
avoids connecting signals to every process you create.

\code
class Example : public ProcessManager
{
  Q_OBJECT
public:
  Example(QObject *parent=0);

protected slots:
  void processFrontendStarted();
  void processFrontendFinished(int, QProcess::ExitStatus);
};

void Example::Example(QObject *parent)
 : ProcessManager(parent)
{
  addFactory(new UnixProcessBackendFactory);
}

void Example::processFrontendStarted()
{
  ProcessManager::processFrontendStarted();
  ProcessFrontend *frontend = qobject_cast<ProcessFrontend *>(sender());
  qDebug() << "Process" << frontend->identifier() << "has started";
}

void Example::processFrontendFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
  ProcessManager::processFrontendFinished(exitCode, exitStatus);
  ProcessFrontend *frontend = qobject_cast<ProcessFrontend *>(sender());
  qDebug() << "Process" << frontend->identifier() << "has finished" << exitCode << exitStatus;
}

\endcode

\section2 Subclass ProcessFrontend objects

To subclass ProcessFrontend objects, override the \l
{ProcessManager::} {createFrontend()} function and return an object
that derived from ProcessFrontend.  For example:

\code

class MyFrontend : public ProcessFrontend {
  Q_OBJECT
public:
  MyFrontend(ProcessBackend *backend) : ProcessFrontend(backend) {}
protected:
  void handleStateChanged(QProcess::ProcessState);
signals:
  void stopped();
};

void MyFrontend::handleStateChanged(QProcess::ProcessState state)
{
  if (state == QProcess::NotRunning)
    emit stopped();
}

class MyManager : public ProcessManager
{
  Q_OBJECT
public:
  MyManager(QObject *parent=0) : ProcessManager(parent) {}
protected :
  ProcessFrontend *createFrontend(ProcessBackend *backend) {
    return new MyFrontend(backend);
  }
};

\endcode

In the above example, the custom \c MyFrontend class raises a new \c
stopped() signal when the child process stops running.  The \c
MyManager class reimplements \l {ProcessManager::} {createFrontend()}
to return a \c MyFrontend objects for each created process.

*/
